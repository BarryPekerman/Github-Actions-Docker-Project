name: Java CI with Maven

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Check out the repository
      uses: actions/checkout@v4 

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: 'maven'

#    - name: Cache Maven dependencies
#      uses: actions/cache@v3
#      with:
#        path: |
#          ~/.m2/repository
#          target/
#        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
#        restore-keys: |
#          ${{ runner.os }}-maven-

#    - name: Clean and Build with Maven
#      run: mvn clean install -B 

    - name: Build App
      run: mvn -B package --file pom.xml

    - name: Create multi-stage Dockerfile
       run: |
       # Creating Dockerfile with optimization techniques
       cat > Dockerfile << 'EOF'
       
       FROM maven:3.9-amazoncorretto-17 AS build
       WORKDIR /app
       
       # Copy only pom.xml first to leverage Docker cache layers
       COPY pom.xml .
       RUN mvn dependency:go-offline
       
       # Copy source and build
       COPY src ./src
       RUN mvn clean package -DskipTests
       
       # Try to detect if this is a Spring Boot app with layering support
       # This creates a conditional build pipeline that works with both
       # regular Java apps and Spring Boot apps with layertools
       RUN mkdir -p extracted && \
        if jar -tf target/*.jar | grep -q "BOOT-INF/layers.idx"; then \
	      echo "Spring Boot layered JAR detected, extracting layers..."; \
	      java -Djarmode=layertools -jar target/*.jar extract --destination extracted; \
        else \
	      echo "Regular JAR detected, using simple copy..."; \
	      mkdir -p extracted/application; \
	      cp target/*.jar extracted/application/; \
        fi
       
       FROM eclipse-temurin:17-jre-alpine
       WORKDIR /app
       
       # Add labels for better maintainability
       LABEL org.opencontainers.image.source=https://github.com/$GITHUB_REPOSITORY
       LABEL org.opencontainers.image.description="Optimized Java application container"
       
       # Security: Create non-root user for running the application
       RUN addgroup --system javauser && adduser --system --ingroup javauser javauser
       
       # Try to copy layers if available, fall back to regular JAR if not
       # This supports both Spring Boot layered apps and regular Java apps
       COPY --from=build --chown=javauser:javauser /app/extracted/ ./
       
       # Set appropriate permissions
       RUN chmod -R u=rX,g=rX /app
       USER javauser
       
       # Alpine optimization: Remove unnecessary files to keep image small
       # Container ready configuration
       ENV JAVA_OPTS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"
       
       EXPOSE 8080
       
       # Dynamic entrypoint that works for both Spring Boot and standard Java apps
       ENTRYPOINT ["sh", "-c", "if [ -f 'org/springframework/boot/loader/JarLauncher.class' ]; then java $JAVA_OPTS org.springframework.boot.loader.JarLauncher; elif [ -d 'application' ]; then java $JAVA_OPTS -jar application/*.jar; else java $JAVA_OPTS -jar *.jar; fi"]
       EOF
    
  
    - name: Upload JAR as an artifact
      if: success()  # Only run this step if the build was successful
      uses: actions/upload-artifact@v4
      with:
        name: app-jar
        path: target/*.jar
        retention-days: 7

